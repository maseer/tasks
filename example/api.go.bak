package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"path/filepath"
	"regexp"
	"strconv"
	"time"

	"github.com/maseer/tasks"
)

// Generated by https://quicktype.io

type Info struct {
	Code    int64  `json:"code"`
	Data    Data   `json:"data"`
	Message string `json:"message"`
}

type Data struct {
	ShopItemID     int64       `json:"shopItemID"`
	ItemID         int64       `json:"itemID"`
	ItemName       string      `json:"itemName"`
	Picture        string      `json:"picture"`
	VersionCode    string      `json:"versionCode"`
	Swiper         []string    `json:"swiper"`
	Content        []string    `json:"content"`
	ContentWidth   interface{} `json:"contentWidth"`
	Attributes     []Attribute `json:"attributes"`
	Skus           []Skus      `json:"skus"`
	Tags           interface{} `json:"tags"`
	MinPrice       int64       `json:"minPrice"`
	ServiceType    int64       `json:"serviceType"`
	ShopID         int64       `json:"shopID"`
	ShopName       string      `json:"shopName"`
	ShopSubName    string      `json:"shopSubName"`
	ShopTopPicture string      `json:"shopTopPicture"`
}

type Attribute struct {
	ID    int64   `json:"id"`
	Name  string  `json:"name"`
	Type  int64   `json:"type"`
	Value []Value `json:"value"`
}

type Value struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

type Skus struct {
	ID           int64            `json:"id"`
	Name         string           `json:"name"`
	Price        int64            `json:"price"`
	BasePrice    int64            `json:"basePrice"`
	LeasePrice   int64            `json:"leasePrice"`
	LeaseDays    int64            `json:"leaseDays"`
	CustomCode   string           `json:"customCode"`
	DiscountRate float64          `json:"discountRate"`
	Picture      string           `json:"picture"`
	Attributes   map[string]int64 `json:"attributes"`
	StockNum     int64            `json:"stockNum"`
}

func getInfo(ping *tasks.Ping) (interface{}, error) {
	s, ok := ping.Data.(int)
	if !ok {
		fmt.Println("err")
		return nil, nil
	}
	const tpl = `https://api.mall.joyway.net/v3/shopsItemsListData/100?pageNum=%d&pageSize=12&sortType=0`
	u := fmt.Sprintf(tpl, s)
	resp, err := http.Get(u)
	if err != nil {
		return nil, err
	}
	bs, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	str := fmt.Sprintf("%s", bs)
	all := []int{}
	re := regexp.MustCompile(`"id":(\d+)`)
	f := re.FindAllStringSubmatch(str, -1)
	for _, v1 := range f {
		i, _ := strconv.Atoi(v1[1])
		all = append(all, i)
	}
	ping.ToMultiple = true
	return all, nil
}

func toJson(ping *tasks.Ping) (interface{}, error) {
	id := ping.Data.(int)
	const tpl = `https://api.mall.joyway.net/v3/items/%d`
	u := fmt.Sprintf(tpl, id)

	resp, err := http.Get(u)
	if err != nil {
		return nil, err
	}
	bs, _ := ioutil.ReadAll(resp.Body)

	i := &Info{}
	if err := json.Unmarshal(bs, i); err != nil {
		return nil, err
	}
	ping.Result.Set(`name`, i.Data.ItemID)
	ping.ToMultiple = true
	return i.Data.Content, nil
}

func handlePic(ping *tasks.Ping) (interface{}, error) {
	i := ping.Result.Get(`name`).(int64)
	if i%3 == 0 {
		return nil, errors.New("double test")
	}
	return ping.Data, nil
}

func down(s, name string) (interface{}, error) {
	res, err := http.Get(s)
	if err != nil {
		return nil, err
	}
	bs, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	ioutil.WriteFile(fmt.Sprintf("tmp/%s_%s", name, filepath.Base(s)), bs, 0777)
	return nil, nil
}

func Down(data *tasks.Ping) (interface{}, error) {
	s := data.Data.(string)
	// d := data.Result.Get("name")
	// r, ok := d.(int64)
	// if ok {
	// 	down(s, fmt.Sprintf("%d", r))
	// }

	// testLock.Lock()
	// rand.Seed(time.Now().Unix())
	// s1 := rand.Intn(10)
	// s2 := int64(s1)
	// time.Sleep(time.Duration(rand.Intn(10)) * time.Millisecond * 50)
	time.Sleep(time.Millisecond * 100)
	// fmt.Println(s)
	// testLock.Unlock()
	// fmt.Printf("%s", s)
	// time.Sleep()
	return s, nil
}

func api() {
	task := tasks.New()
	task.Add(getInfo, toJson, handlePic, Down)
	//task.StartInt([]int{4})
	//task.StartInt([]int{1, 2, 3, 4})
	//res := task.Begin()
	//fmt.Printf("\nfinished[%d]\n", len(res))
	// for _, v := range res {
	// 	if v.Err != nil {
	// 		fmt.Println(v.Err)
	// 	}
	// }
}
